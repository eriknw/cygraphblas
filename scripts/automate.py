import copy
import os
import textwrap
import pycparser
import tlz
from pycparser import c_ast, c_generator, parse_file

BACKENDS = [
    'SS',
    'GBTL',
]

AUTO = '# This file is automatically generated'
GRB_DEFINES = {
    'GRB_VERSION': 'int64_t',
    'GRB_SUBVERSION': 'int64_t',
}
SS_DEFINES = {
    '*GxB_IMPLEMENTATION_ABOUT': 'char',
    '*GxB_IMPLEMENTATION_DATE': 'char',
    '*GxB_IMPLEMENTATION_LICENSE': 'char',
    '*GxB_IMPLEMENTATION_NAME': 'char',
    '*GxB_SPEC_ABOUT': 'char',
    '*GxB_SPEC_DATE': 'char',
    'GxB_CHUNK': 'int64_t',
    'GxB_GPU_CHUNK': 'int64_t',
    'GxB_GPU_CONTROL': 'int64_t',
    'GxB_IMPLEMENTATION': 'int64_t',
    'GxB_IMPLEMENTATION_MAJOR': 'int64_t',
    'GxB_IMPLEMENTATION_MINOR': 'int64_t',
    'GxB_IMPLEMENTATION_SUB': 'int64_t',
    'GxB_MKL': 'int64_t',
    'GxB_NTHREADS': 'int64_t',
    'GxB_SPEC_MAJOR': 'int64_t',
    'GxB_SPEC_MINOR': 'int64_t',
    'GxB_SPEC_SUB': 'int64_t',
    'GxB_SPEC_VERSION': 'int64_t',
    'GxB_STDC_VERSION': 'int64_t',
    'GxB_INDEX_MAX': 'uint64_t',
}
SS_SLICING_DEFINES = {
    'GxB_RANGE': 'int64_t',
    'GxB_STRIDE': 'int64_t',
    'GxB_BACKWARDS': 'int64_t',
    'GxB_BEGIN': 'int64_t',
    'GxB_END': 'int64_t',
    'GxB_INC': 'int64_t',
}
GrB_DEPRECATED = {
    'GrB_SCMP',
    # GrB_wait(void)
}

SS_DEPRECATED = {
    'GrB_eWiseMult_Vector_Semiring',
    'GrB_eWiseMult_Vector_Monoid',
    'GrB_eWiseMult_Vector_BinaryOp',
    'GrB_eWiseMult_Matrix_Semiring',
    'GrB_eWiseMult_Matrix_Monoid',
    'GrB_eWiseMult_Matrix_BinaryOp',
    'GrB_eWiseAdd_Vector_Semiring',
    'GrB_eWiseAdd_Vector_Monoid',
    'GrB_eWiseAdd_Vector_BinaryOp',
    'GrB_eWiseAdd_Matrix_Semiring',
    'GrB_eWiseAdd_Matrix_Monoid',
    'GrB_eWiseAdd_Matrix_BinaryOp',
}
DEPRECATED = GrB_DEPRECATED | SS_DEPRECATED


def get_basedir():
    thisdir = os.path.dirname(__file__)
    return os.path.join(thisdir, '..')


def pyname(cname):
    while cname.startswith('*'):
        cname = cname[1:]
    if cname.startswith('GxB_') or cname.startswith('GrB_'):
        return cname[4:]
    if cname.startswith('GB_'):
        return cname[3:]
    raise ValueError(f'Unable to create Python name for: {cname}')


class VisitEnumTypedef(c_generator.CGenerator):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.results = []

    def visit_Typedef(self, node):
        rv = super().visit_Typedef(node)
        if isinstance(node.type.type, c_ast.Enum):
            self.results.append(rv + ';')
        return rv


def get_ast(filename):
    fake_include = os.path.dirname(pycparser.__file__) + 'utils/fake_libc_include'
    ast = parse_file(filename, cpp_args=f'-I{fake_include}')
    return ast


def get_groups(ast):
    generator = c_generator.CGenerator()
    lines = generator.visit(ast).splitlines()

    seen = set()
    groups = {}
    vals = {x for x in lines if 'extern GrB_Info GxB' in x} - seen
    seen.update(vals)
    groups['GxB methods'] = sorted(vals)

    vals = {x for x in lines if 'extern GrB_Info GrB' in x} - seen
    seen.update(vals)
    groups['GrB methods'] = sorted(vals)

    vals = {x for x in lines if 'extern GrB_Info GB' in x} - seen
    seen.update(vals)
    groups['GB methods'] = sorted(vals)

    missing_methods = {x for x in lines if 'extern GrB_Info ' in x} - seen
    assert not missing_methods

    vals = {x for x in lines if 'extern GrB' in x} - seen
    seen.update(vals)
    groups['GrB objects'] = sorted(vals)

    vals = {x for x in lines if 'extern GxB' in x} - seen
    seen.update(vals)
    groups['GxB objects'] = sorted(vals)

    vals = {x for x in lines if 'extern const' in x and 'GxB' in x} - seen
    seen.update(vals)
    groups['GxB const'] = sorted(vals)

    vals = {x for x in lines if 'extern const' in x and 'GrB' in x} - seen
    seen.update(vals)
    groups['GrB const'] = sorted(vals)

    missing_const = {x for x in lines if 'extern const' in x} - seen
    assert not missing_const

    vals = {x for x in lines if 'typedef' in x and 'GxB' in x and '(' not in x} - seen
    seen.update(vals)
    groups['GxB typedef'] = sorted(vals)

    vals = {x for x in lines if 'typedef' in x and 'GrB' in x and '(' not in x} - seen
    seen.update(vals)
    groups['GrB typedef'] = sorted(vals)

    missing_typedefs = {x for x in lines if 'typedef' in x and 'GB' in x and '(' not in x} - seen
    assert not missing_typedefs
    assert all(x.endswith(';') for x in seen)  # sanity check

    g = VisitEnumTypedef()
    _ = g.visit(ast)
    enums = g.results

    vals = {x for x in enums if '} GrB' in x}
    for val in vals:
        seen.update(val.splitlines())
    groups['GrB typedef enums'] = sorted(vals, key=lambda x: x.rsplit('}', 1)[-1])

    vals = {x for x in enums if '} GxB' in x}
    for val in vals:
        seen.update(val.splitlines())
    groups['GxB typedef enums'] = sorted(vals, key=lambda x: x.rsplit('}', 1)[-1])

    missing_enums = set(enums) - set(groups['GrB typedef enums']) - set(groups['GxB typedef enums'])
    assert not missing_enums

    vals = {x for x in lines if 'typedef' in x and 'GxB' in x} - seen
    seen.update(vals)
    groups['GxB typedef funcs'] = sorted(vals)

    vals = {x for x in lines if 'typedef' in x and 'GrB' in x} - seen
    assert not vals
    groups['not seen'] = sorted(set(lines) - seen)
    return groups


def get_group_info(groups, ast):
    rv = {}

    def handle_constants(group):
        for line in group:
            extern, const, ctype, cname = line.split(' ')
            assert cname.endswith(';')
            cname = cname[:-1].replace('(void)', '()')
            assert extern == 'extern'
            assert const == 'const'
            if cname in DEPRECATED:
                continue
            info = {
                'ctype': ctype,
                'cname': cname,
                'pyname': pyname(cname),
                'text': line,
            }
            if ctype == 'uint64_t' and cname.startswith('*'):
                info['pycast'] = '<uintptr_t>'
            yield info

    rv['GrB const'] = list(handle_constants(groups['GrB const']))
    rv['GxB const'] = list(handle_constants(groups['GxB const']))

    def handle_objects(group):
        for line in group:
            extern, ctype, cname = line.split(' ')
            assert cname.endswith(';')
            cname = cname[:-1]
            assert extern == 'extern'
            if cname in DEPRECATED:
                continue
            info = {
                'ctype': ctype,
                'cname': cname,
                'pytype': pyname(ctype),
                'pyname': pyname(cname),
                'text': line,
            }
            yield info

    rv['GrB objects'] = list(handle_objects(groups['GrB objects']))
    rv['GxB objects'] = list(handle_objects(groups['GxB objects']))

    def handle_enums(group):
        for text in group:
            typedef, bracket, *fields, cname = text.splitlines()
            assert typedef.strip() == 'typedef enum'
            assert bracket == '{'
            assert cname.startswith('}')
            assert cname.endswith(';')
            cname = cname[1:-1].strip()
            if cname in DEPRECATED:
                continue
            new_fields = []
            for field in fields:
                if field.endswith(','):
                    field = field[:-1]
                field = field.strip()
                cfieldname, eq, val = field.split(' ')
                assert eq == '='
                fieldinfo = {
                    'cname': cfieldname,
                    'pyname': pyname(cfieldname),
                    'value': val,
                    'text': field,
                    'pytype': pyname(cname),
                }
                if cfieldname in DEPRECATED:
                    continue
                new_fields.append(fieldinfo)
            info = {
                'cname': cname,
                'pyname': pyname(cname),
                'fields': new_fields,
                'text': text,
            }
            yield info

    rv['GrB typedef enums'] = list(handle_enums(groups['GrB typedef enums']))
    rv['GxB typedef enums'] = list(handle_enums(groups['GxB typedef enums']))

    def handle_typedefs(group):
        for line in group:
            typedef, *ctypes, cname = line.split(' ')
            ctype = ctypes[-1]
            is_struct = ctypes[0] == 'struct'
            # assert is_struct == (len(ctypes) == 2), line
            assert typedef == 'typedef'
            assert cname.endswith(';')
            cname = cname[:-1]
            if cname in DEPRECATED:
                continue
            info = {
                'cname': cname,
                'ctype': ctype,
                'is_struct': is_struct,
                'pyname': pyname(cname),
                'text': line,
            }
            yield info

    rv['GrB typedef'] = list(handle_typedefs(groups['GrB typedef']))
    rv['GxB typedef'] = list(handle_typedefs(groups['GxB typedef']))

    def handle_typedef_funcs(group):
        for line in group:
            assert line.endswith(';') and line.startswith('typedef')
            info = {
                'ctypedef': 'c' + line[:-1].replace('bool', 'bint'),
                'text': line,
            }
            yield info

    rv['GxB typedef funcs'] = list(handle_typedef_funcs(groups['GxB typedef funcs']))

    class FuncDeclVisitor(c_ast.NodeVisitor):
        def __init__(self):
            self.functions = []

        def visit_Decl(self, node):
            if (
                isinstance(node.type, c_ast.FuncDecl)
                and node.storage == ['extern']
                and node.quals != ['const']  # e.g., skip GrB_error
            ):
                self.functions.append(node)

    def handle_function_node(node):
        if generator.visit(node.type.type) != 'GrB_Info':
            raise ValueError(generator.visit(node))
        if node.name in DEPRECATED:
            return
        cnode = copy.deepcopy(node)
        pynode = copy.deepcopy(node)

        cnode.storage = []
        pynode.storage = []
        pynode.name = pyname(node.name)
        pynode.type.type.declname = pynode.name
        cnode_t = copy.deepcopy(cnode)
        pynode_t = copy.deepcopy(pynode)
        arg_num_pointers = []
        arg_names = []
        arg_pytypes = []
        if generator.visit(node.type.args) == 'void':
            # show `func()` instead of `func(void)`
            cnode.type.args.params = []
            pynode.type.args.params = []
            cnode_t.type.args.params = []
            pynode_t.type.args.params = []
        else:
            params = zip(cnode.type.args.params, cnode_t.type.args.params, pynode.type.args.params, pynode_t.type.args.params)
            for i, (carg, carg_t, pyarg, pyarg_t) in enumerate(params):
                if type(carg) is c_ast.Typename:
                    raise ValueError(f'Argument is unnamed.  Is this function deprecated?\n- {generator.visit(node)}\n- {generator.visit(carg)}')
                if type(carg) is not c_ast.Decl and generator.visit(carg) != 'void' and type(carg) is not c_ast.EllipsisParam:
                    raise ValueError(generator.visit(carg))

                if type(carg) is c_ast.EllipsisParam:
                    arg_num_pointers.append(0)
                    continue
                elif type(carg) is c_ast.Decl:
                    # print('A', i, generator.visit(pynode), generator.visit(pyarg_t), type(pyarg_t))
                    # Delete the name for type-only AST
                    c_t = carg_t
                    py = pyarg
                    py_t = pyarg_t
                    while not hasattr(c_t, 'declname'):
                        c_t = c_t.type
                        py_t = py_t.type
                        py = py.type
                    c_t.declname = ''
                    py_t.declname = ''

                    # Update the type name for Python
                    c = carg
                    c_t = carg_t
                    py = pyarg
                    py_t = pyarg_t
                    while hasattr(py, 'type'):
                        # print('B', i, generator.visit(py), type(py))
                        c = c.type
                        c_t = c_t.type
                        py = py.type
                        py_t = py_t.type
                    # print('C', i, generator.visit(py), type(py))
                    if 'bool' in py.names:
                        assert len(py.names) == 1
                        c.names[0] = 'bint'
                        c_t.names[0] = 'bint'
                        py.names[0] = 'bint'
                        py_t.names[0] = 'bint'
                    elif 'GxB_FC32_t' in py.names:
                        assert len(py.names) == 1
                        c.names[:] = ['float', 'complex']
                        c_t.names[:] = ['float', 'complex']
                        py.names[:] = ['float', 'complex']
                        py_t.names[:] = ['float', 'complex']
                    elif 'GxB_FC64_t' in py.names:
                        assert len(py.names) == 1
                        c.names[:] = ['double', 'complex']
                        c_t.names[:] = ['double', 'complex']
                        py.names[:] = ['double', 'complex']
                        py_t.names[:] = ['double', 'complex']
                    elif py.names[0] not in {
                        'FILE', 'bool', 'char', 'double', 'float', 'int16_t', 'int32_t', 'int64_t', 'int8_t',
                        'size_t', 'uint16_t', 'uint32_t', 'uint64_t', 'uint8_t', 'unsigned', 'void',
                    }:
                        assert len(py.names) == 1
                        name = pyname(py.names[0])
                        py.names[0] = name
                        py_t.names[0] = name

                    # Don't use pointers or const for any API
                    # TODO: handle scalar (etc) return types that are pointers!
                    assert type(pyarg) is c_ast.Decl
                    # print(pyarg.show(attrnames=True, nodenames=True))
                    c = carg.type
                    c_t = carg_t.type
                    py = pyarg.type
                    py_t = pyarg_t.type
                    count = 0
                    if getattr(py, 'quals', None) == ['const']:
                        c.quals = []
                        c_t.quals = []
                        py.quals = []
                        py_t.quals = []
                    while type(py) is c_ast.PtrDecl:
                        c = c.type
                        c_t = c_t.type
                        py = py.type
                        py_t = py_t.type
                        if getattr(py, 'quals', None) == ['const']:
                            c.quals = []
                            c_t.quals = []
                            py.quals = []
                            py_t.quals = []
                        count += 1

                    pyarg.type = py
                    pyarg_t.type = py_t
                    #pynode.type.args.params[i] = py
                    #pynode_t.type.args.params[i] = py_t

                    arg_num_pointers.append(count)
                    arg_names.append(carg.name)
                    arg_pytypes.append(generator.visit(py_t))
                    # print(i, generator.visit(pynode))
                    # print(i, generator.visit(node))
                else:
                    raise ValueError(generator.visit(arg))
                # print(generator.visit(pynode))
            # print(generator.visit(pynode))

        text = generator.visit(node)
        if 'GrB_Matrix' in text:
            group = 'matrix'
        elif 'GrB_Vector' in text:
            group = 'vector'
        elif 'GxB_Scalar' in text:
            group = 'scalar'
        else:
            group = pynode.name.split('_', 1)[0]
            group = {
                # Apply our naming scheme
                'GrB_Matrix': 'matrix',
                'GrB_Vector': 'vector',
                'GxB_Scalar': 'scalar',
                'SelectOp': 'selectop',
                'BinaryOp': 'binary',
                'Desc': 'descriptor',
                'Descriptor': 'descriptor',
                'Monoid': 'monoid',
                'Semiring': 'semiring',
                'Type': 'dtype',
                'UnaryOp': 'unary',
                # "everything else" is "core"
                'getVersion': 'core',
                'Global': 'core',
                'cuda': 'core',
                'finalize': 'core',
                'init': 'core',
                'wait': 'core',
            }[group]
        return {
            # names
            'cname': node.name,
            'pyname': pynode.name,
            # attributes
            'group': group,
            'arg_num_pointers': arg_num_pointers,  # number of `*` of type of each arg
            'arg_names': arg_names,
            'arg_pytypes': arg_pytypes,
            # AST nodes
            'cnode': cnode,
            'cnode_t': cnode_t,
            'pynode': pynode,
            'pynode_t': pynode_t,
            # text
            'ctext': generator.visit(cnode),
            'ctext_t': generator.visit(cnode_t),
            'pytext': generator.visit(pynode),
            'pytext_t': generator.visit(pynode_t),
        }

    generator = c_generator.CGenerator()
    visitor = FuncDeclVisitor()
    visitor.visit(ast)
    grb_nodes = [node for node in visitor.functions if node.name.startswith('GrB_')]
    gxb_nodes = [node for node in visitor.functions if node.name.startswith('GxB_')]
    gb_nodes = [node for node in visitor.functions if node.name.startswith('GB_')]
    assert len(grb_nodes) == len(groups['GrB methods'])
    assert len(gxb_nodes) == len(groups['GxB methods'])
    assert len(gb_nodes) == len(groups['GB methods'])

    grb_funcs = (handle_function_node(node) for node in grb_nodes)
    gxb_funcs = (handle_function_node(node) for node in gxb_nodes)
    gb_funcs = (handle_function_node(node) for node in gb_nodes)
    grb_funcs = [x for x in grb_funcs if x is not None]
    gxb_funcs = [x for x in gxb_funcs if x is not None]
    gb_funcs = [x for x in gb_funcs if x is not None]

    rv['GrB methods'] = sorted(grb_funcs, key=lambda x: generator.visit(x['cnode']))
    rv['GxB methods'] = sorted(gxb_funcs, key=lambda x: generator.visit(x['cnode']))
    rv['GB methods'] = sorted(gb_funcs, key=lambda x: generator.visit(x['cnode']))
    #print('\n'.join(x['pytext'] for x in rv['GrB methods']))
    #1/0

    """
    import tlz
    data = tlz.groupby(lambda x: x['pytext_t'].split('(', 1)[-1], rv['GrB methods'] + rv['GxB methods'] + rv['GB methods'])
    # print(sorted(data))
    # print(type(data['GrB_Info wait()'][0]))
    data = tlz.valmap(lambda vals: [x['pyname'] for x in vals], data)
    for key in sorted(data):
        print(key)
        for val in data[key]:
            print('   ', val)
    """
    return rv


def get_suitesparse_pxd(groups):
    groups = dict(groups)
    text = [
        AUTO,
        'from libc.stdint cimport int8_t, int16_t, int32_t, int64_t, uint8_t, uint16_t, uint32_t, uint64_t',
        'from libc.stdio cimport FILE',
        '',
        'cdef extern from "GraphBLAS.h" nogil:',
        '    # #defines',
    ]
    for name, typ in sorted(GRB_DEFINES.items()) + sorted(SS_DEFINES.items(), key=lambda x: (x[1], x[0])):
        text.append(f'    const {typ} {name}')
    text.append('    # slicing #defines')
    for name, typ in sorted(SS_SLICING_DEFINES.items()):
        text.append(f'    const {typ} {name}')

    def handle_typedefs(group):
        for info in group:
            if '_Complex' in info['text']:
                continue
            if info['is_struct']:
                yield f'    ctypedef struct {info["ctype"]}:'
                yield '        pass'
            yield f'    ctypedef {info["ctype"]} {info["cname"]}'

    text.append('')
    text.append('    # GrB typedefs')
    text.extend(handle_typedefs(groups['GrB typedef']))
    text.append('')
    text.append('    # GxB typedefs')
    text.extend(handle_typedefs(groups['GxB typedef']))
    text.append('')
    text.append('    # GxB typedefs (functions)')
    text.extend(f'    {info["ctypedef"]}' for info in groups['GxB typedef funcs'])

    def handle_enums(group):
        for info in group:
            yield f'    ctypedef enum {info["cname"]}:'
            for field in info['fields']:
                yield f'        {field["cname"]}'

    text.append('')
    text.append('    # GrB enums')
    text.extend(handle_enums(groups['GrB typedef enums']))
    text.append('')
    text.append('    # GxB enums')
    text.extend(handle_enums(groups['GxB typedef enums']))

    # print('\n'.join(x['text'] for x in groups['GrB const']))
    def handle_consts(group):
        for info in group:
            yield f'    const {info["ctype"]} {info["cname"]}'

    text.append('')
    text.append('    # GrB consts')
    text.extend(handle_consts(groups['GrB const']))
    text.append('')
    text.append('    # GxB consts')
    text.extend(handle_consts(groups['GxB const']))

    def handle_objects(group):
        for info in group:
            yield f'    {info["ctype"]} {info["cname"]}'

    text.append('')
    text.append('    # GrB objects')
    text.extend(handle_objects(x for x in groups['GrB objects'] if 'GxB' not in x['text']))
    text.append('')
    text.append('    # GrB objects (extended)')
    text.extend(handle_objects(x for x in groups['GrB objects'] if 'GxB' in x['text']))
    text.append('')
    text.append('    # GxB objects')
    text.extend(handle_objects(groups['GxB objects']))

    def handle_funcs(group):
        groups = tlz.groupby('group', group)
        for name in sorted(groups):
            yield ''
            yield f'    # {name}'
            for info in groups[name]:
                yield f'    {info["ctext_t"]}'

    text.append('')
    text.append('    #################')
    text.append('    # GrB functions #')
    text.append('    #################')
    text.extend(handle_funcs(groups['GrB methods']))
    text.append('')
    text.append('    ################')
    text.append('    # GB functions #')
    text.append('    ################')
    text.extend(handle_funcs(groups['GB methods']))
    text.append('')
    text.append('    #################')
    text.append('    # GxB functions #')
    text.append('    #################')
    text.extend(handle_funcs(groups['GxB methods']))
    return '\n'.join(text)


def main(basedir):
    thisdir = os.path.dirname(__file__)
    ast = get_ast(os.path.join(thisdir, 'GraphBLAS-processed.h'))
    groups = get_groups(ast)
    groups = get_group_info(groups, ast)
    pxd = get_suitesparse_pxd(groups)

    filename = os.path.join(basedir, 'cygraphblas_ss', 'graphblas.pxd')
    print(f'Writing {filename}')
    with open(filename, 'w') as f:
        f.write(pxd)

    def handle_lib(objects, enums, is_pyx=False, extra=None):
        text = [
            AUTO,
        ]
        if not is_pyx:
            text.append('from cygraphblas.wrappertypes cimport BinaryOp, Descriptor, Monoid, Semiring, UnaryOp, Type')
            text.append('from cygraphblas.wrappertypes.constants cimport Desc_Field, Desc_Value, Info, Mode')

        if extra is not None:
            text.extend(extra)

        text.append('')
        text.append('# Enums')
        for info in sorted(enums, key=lambda x: x['pyname']):
            for field in info['fields']:
                if is_pyx:
                    text.append(f'cdef {field["pytype"]} {field["pyname"]} = {field["pytype"]}._new("{field["cname"]}")')
                else:
                    text.append(f'cdef {field["pytype"]} {field["pyname"]}')

        prev_pytype = None
        for info in objects:
            if info['pytype'] != prev_pytype:
                prev_pytype = info['pytype']
                text.append('')
                text.append(f'# {prev_pytype}')
            if is_pyx:
                text.append(f'cdef {info["pytype"]} {info["pyname"]} = {info["pytype"]}._new("{info["cname"]}")')
            else:
                text.append(f'cdef {info["pytype"]} {info["pyname"]}')
        return text

    def get_enums(group, field_filter):
        rv = []
        for info in group:
            val = dict(info)
            val['fields'] = sorted((val for val in info['fields'] if val['cname'].startswith(field_filter)), key=lambda x: x['pyname'])
            rv.append(val)
        return rv

    group = [info for info in groups['GrB objects'] if 'GxB' not in info['text']]
    enums = get_enums(groups['GrB typedef enums'], 'GrB')
    extra = [
        'from libc.stdint cimport int8_t, INT8_MIN',
        '',
        'ctypedef int8_t backend_id_t',
        'cdef backend_id_t NBACKENDS',
    ]
    extra.extend(f'cdef backend_id_t BACKEND_{backend}' for backend in BACKENDS)
    extra.extend([
        'cdef char *BACKEND_NAMES[CYGB_NBACKENDS]',
    ])
    text = handle_lib(group, enums, is_pyx=False, extra=extra)
    filename = os.path.join(basedir, 'cygraphblas', '_clib.pxd')
    # filename = os.path.join(basedir, 'cygraphblas', '_clib', '__init__.pxd')
    print(f'Writing {filename}')
    with open(filename, 'w') as f:
        f.write('\n'.join(text))

    extra = [
        '',
        'cdef backend_id_t NBACKENDS = 0',
        'cdef char *BACKEND_NAMES[CYGB_NBACKENDS]',
    ]
    for backend in BACKENDS:
        extra.extend([
            f'IF CYGB_{backend}:',
            f'    cdef backend_id_t BACKEND_{backend} = NBACKENDS',
            f'    BACKEND_NAMES[NBACKENDS] = "{backend}"',
            f'    NBACKENDS += 1',
            'ELSE:',
            f'    cdef backend_id_t BACKEND_{backend} = INT8_MIN',
        ])

    text = handle_lib(group, enums, is_pyx=True, extra=extra)
    # filename = os.path.join(basedir, 'cygraphblas', '_clib', '__init__.pyx')
    filename = os.path.join(basedir, 'cygraphblas', '_clib.pyx')
    print(f'Writing {filename}')
    with open(filename, 'w') as f:
        f.write('\n'.join(text))

    def handle_lib_object(group, pytype, altimport=None):
        group = [info for info in group if info['pytype'] == pytype]
        text = [
            AUTO,
        ]
        if not group:
            return text
        if altimport is None:
            text.append('from cygraphblas cimport _clib as clib')
        else:
            text.append(altimport)
        text.append('')
        for info in group:
            text.append(f'{info["pyname"]} = clib.{info["pyname"]}')
        return text

    object_info = [
        ('binary', 'BinaryOp'),
        ('descriptor', 'Descriptor'),
        ('monoid', 'Monoid'),
        ('semiring', 'Semiring'),
        ('dtypes', 'Type'),
        ('unary', 'UnaryOp'),
    ]
    for name, pytype in object_info:
        text = handle_lib_object(group, pytype)
        if not text:
            continue
        filename = os.path.join(basedir, 'cygraphblas', 'lib', name, '__init__.pyx')
        print(f'Writing {filename}')
        with open(filename, 'w') as f:
            f.write('\n'.join(text))

    for info in enums:
        text = handle_lib_object(info['fields'], info['pyname'])
        filename = os.path.join(basedir, 'cygraphblas', 'lib', 'constants', info['pyname'].lower(), '__init__.pyx')
        print(f'Writing {filename}')
        with open(filename, 'w') as f:
            f.write('\n'.join(text))

    # Now do SuiteSparse-specific things (in cygraphblas_ss!)
    def handle_init(group, altimport=None):
        text = [
            AUTO,
        ]
        if altimport is None:
            text.append('from cygraphblas cimport _clib as clib')
        else:
            text.append(altimport)
        text.append('from cygraphblas_ss cimport graphblas as ss')
        prev_pytype = None
        for info in group:
            if info['pytype'] != prev_pytype:
                prev_pytype = info['pytype']
                text.append('')
                text.append(f'# {prev_pytype}')
            text.append(f'clib.{info["pyname"]}.ss_obj = ss.{info["cname"]}')
        return text

    grb_enums = []
    for info in enums:
        grb_enums.extend(info['fields'])

    text = handle_init(grb_enums + group)
    filename = os.path.join(basedir, 'cygraphblas_ss', 'initialize.pyx')
    print(f'Writing {filename}')
    with open(filename, 'w') as f:
        f.write('\n'.join(text))

    group = [info for info in groups['GrB objects'] if 'GxB' in info['text']]
    gxb_group = sorted(group + groups['GxB objects'], key=lambda info: info['pytype'])
    extra = [
        'from cygraphblas_ss.wrappertypes cimport SelectOp',
        'from cygraphblas_ss.wrappertypes.constants cimport Format_Value, Option_Field, Print_Level, Thread_Model'
    ]
    enums = (
        get_enums(groups['GrB typedef enums'], 'GxB')
        + get_enums(groups['GxB typedef enums'], 'GxB')
    )
    text = handle_lib(gxb_group, enums, is_pyx=False, extra=extra)
    filename = os.path.join(basedir, 'cygraphblas_ss', '_clib.pxd')
    print(f'Writing {filename}')
    with open(filename, 'w') as f:
        f.write('\n'.join(text))

    text = handle_lib(gxb_group, enums, is_pyx=True)  #, extra=extra)
    filename = os.path.join(basedir, 'cygraphblas_ss', '_clib.pyx')
    print(f'Writing {filename}')
    with open(filename, 'w') as f:
        f.write('\n'.join(text))

    # Suitesparse GxB extensions of GrB objects
    altimport = 'from cygraphblas_ss cimport _clib as clib'
    for name, pytype in object_info + [('selectop', 'SelectOp')]:
        text = handle_lib_object(gxb_group, pytype, altimport=altimport)
        filename = os.path.join(basedir, 'cygraphblas_ss', 'lib', f'{name}.pyx')
        print(f'Writing {filename}')
        with open(filename, 'w') as f:
            f.write('\n'.join(text))

    gxb_enums = []
    for info in enums:
        gxb_enums.extend(info['fields'])

    text = handle_init(gxb_enums + gxb_group, altimport=altimport)
    filename = os.path.join(basedir, 'cygraphblas_ss', 'initialize_ss.pyx')
    print(f'Writing {filename}')
    with open(filename, 'w') as f:
        f.write('\n'.join(text))

    for info in enums:
        text = handle_lib_object(info['fields'], info['pyname'], altimport=altimport)
        filename = os.path.join(basedir, 'cygraphblas_ss', 'lib', 'constants', f"{info['pyname'].lower()}.pyx")
        print(f'Writing {filename}')
        with open(filename, 'w') as f:
            f.write('\n'.join(text))


if __name__ == '__main__':
    main(get_basedir())
